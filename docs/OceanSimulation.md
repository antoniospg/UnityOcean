<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

# Realistic Ocean Simulation Silvaa
![overview](img/overview.png)

**Figure 1:** Simulated water surface with a realistic surface shader in a grid of 256x256 and a total size of 100 meters. 

## Introduction
In this project, I will implement the statistical wave model from the equations in Tessendorf's paper[1] on simulating ocean water. The ocean rendering technique in this sample applies heightmap generation by summing a vast number of waves using the Fast Fourier Transform, with user-controllable size and resolution, and which can be tiled seamlessly over a larger domain.
The main principle of Ocean rendering is that it can be modeled very well by thinking of it a sum of "infinite" waves at different amplitudes traveling in different directions. These waves aren't randomly chosen; it comes from using statistical-empirical models of the ocean, based on oceanographic research. In this article, I will show how to recreate and animate the ocean surface and add critical visual features like foam and illumination.

## Waves and the Fourier Tansform
This technique consists of doing an inverse Fourier transform on the frequency spectrum of the ocean height field to get the space domain representation of this same field, at each time frame. For every frame, we calculate, for each point (x,z) in a rectangular grid, the y component of this point, which represents the ocean height at that point.
Given the ocean height field function in the spatial frequency domain $$ \tilde h(\pmb{k}, t) $$, to find the original function in the spatial domain, we need to perform the inverse Fourier Transform, that is, evaluate the integral above (note that we supress the twiddle factor):

$$
\int_{-\infty}^{\infty}  \tilde h(\pmb{k},t).exp(i\pmb{k.x})d\pmb{k}
$$

To perform this calculation, its necessary to sample the signal in a discreate interval over a support domain. So the integral becomes a summation, expressed by:

$$
h(\pmb{x}, t) = \sum_{\pmb{k}} \tilde h(\pmb{x},t).exp(i\pmb{k.x})
$$

where **k** is the wave vector, and can be defined as:

$$
\pmb{k} = (k_x, k_z)
\\~\\
k_x = \frac{2\pi n}{L_x}
\\~\\
k_z = \frac{2\pi m}{L_z}
$$

where:

$$
-\frac{N}{2} \leq  n \leq \frac{N}{2}
\\~\\
-\frac{M}{2} \leq  m \leq \frac{M}{2}
$$

but, for most of our work, we deal with variables i and j in different domains:

$$
0 \leq i <N
\\
0 \leq j <M
$$

so, we can make the transformation:

$$
n = i - \frac{N}{2}
\\~\\
m = j - \frac{M}{2}
$$

The fft process generates the height field at discrete points:

$$
 \pmb{x} = (\frac{nL_x}{N}, \frac{mL_z}{M})
$$

## The FFT
To compute the Fourier Transform, we need to calculate the summation in the previous section; this requires a complexity of O(n²) for a 1-D Fourier Transform, which is terrible, especially when we need to perform 2-D operations in a real-time system. The best approach is using the FFT(Fast Fourier Transform) algorithm, which implements the calculation with an O(nlog(n)) complexity for 1-D data. The algorithm is quite complicated, but essentially, for a RADIX-2 FFT, it splits recursively into half the data, performing calculations using the cyclic property of the n-th roots of unity, this way, avoiding unnecessary calculations. Above is a simple example of the algorithm for 1-D data with eight elements; the peculiar structure of this graph also gives the name the Butterfly algorithm to the FFT.

![](img/fftsample.gif) 

**Figure 2:** Butterfly Algorithm.

At this point, we can ask ourselves how big the grid should be? The answer is that it depends if you make these calculations on the GPU or CPU. On GPU, especially implementing it on a shader, the calculations can be made much faster due to the massive parallelization power of the GPU, for those, in a real-time system, a grid between 128x128 and 512x512 is enough. If you want to do this in the CPU, the grid's resolution can be quite limited. In my implementation, 64x64 was the best resolution I could get. 

## Statistical Wave Model

The height field realization can be seen as a sum of sine with complex amplitudes that vary in time, that is, like every signal, it can be generated by its Fourier coefficients, allowing us to write:

$$
h(\pmb{x}, t) = \sum_{\pmb{k}} \tilde h(\pmb{x},t).exp(i\pmb{k.x})
$$

As observed in oceanographic research

The expression of the frequencies is given by:

$$
\tilde h(\pmb{k},t) = \tilde h_o(\pmb{k})exp(i\omega(\pmb{k})t) + \tilde h_o^*(\pmb{-k})exp(-i\omega(\pmb{k})t)
$$

where :
* $$ \tilde h_o(\pmb{k}) $$ is the expression of the initial value of the spectrum at time t = 0.
*  $$ \tilde h_o^*(\pmb{-k}) $$ is the complex conjugate of $$ \tilde h_o(\pmb{-k}) $$.
* $$ \omega(\pmb{k}) $$ is the dispertion relation, given by: $$ \omega(k) = \sqrt{gk} $$.
 * k is the length of the wave vector.

This equation is responsible to animate the waves over time, the complex conjugate term ensures breaking waves by propagating waves “to the left” and “to the right. The dispersion relation is a expression that relationates the wave vector to the frequency, and its based on real physics models of ocean water.

Now, we want to show how to get in the initial value of the spectrum, to do this, its require to use a oceanographic model to get the average squared mean of this variable, that is:
 
$$
P_h(\pmb{k}) = \langle |\tilde h^*(\pmb{k},t)|^2 \rangle
$$

For $$ P_h $$, we will choose a semi-emphyrical model obtainded from oceanographic research known as Phillips Spectrum, that is given by:

$$
P_h(\pmb{k}) = A\frac{exp(-1/(kL)^2)}{k^4} |\hat{\pmb{k}}.\hat{\pmb{v}}|^2
\\~\\
L= \frac{v²}{g}
$$

if you want to supress waves smaller that a small length l << L, just add this multiplicative factor to the Phillips Spectrum:

$$
exp(-(kl)²)
$$

where:
* A is a numeric constant.
* **k** is the wave vector
* g is the gravitational constant
* **v** is the wind speed

It is observed that realizations of water wave height fields are gaussian random numbers with spatial spectra of a prescribed form. This is most efficiently accomplished directly in the fourier domain. The fourier amplitudes of a wave height field can be produced by:

$$
\tilde h_o(\pmb{k}) = \frac{(\xi_r + i\xi_i)}{\sqrt{2}} \sqrt{P_h(\pmb{k})}
$$

where $$ \xi_r $$ and $$ \xi_i $$ comes from random numbers of a gaussian distribuition with mean zero and standard deviation 1.

## Additional calculations 
### Normals
Due to illuminations effects, we need to calculate the normals of the ocean surface at each point, to do this, instead of performing another FFT, to save processing time, we will simply do a central differentiation over the height field, in order to obtain the gradient $$ \epsilon(\pmb{x},t) = \nabla h(\pmb{x},t) $$ of the function. With the gradient, its easy to find the normals, using the relation above:

$$
\hat{n}_s(\pmb{x},t) = \frac{\hat{y} - \epsilon(\pmb{x},t)}{\sqrt{1+\epsilon^2(\pmb{x},t)}}
$$

### Horizontal Displacement
At that point, our surface has rounded peak waves that just represent a calm ocean, in order to have sharpen peaks, its useful to do an aditional calculation of the horizontals displacements. Ocean waves aren't just made by oscilations in the y direction,  there exists oscillations in the horizontal directions to, to compute these, we need to project the spectrum in the z and x axis, that is, findind a horizontal displacement given by:

$$
\pmb{D}(\pmb{x},t) = \sum_{\pmb{k}}-i\frac{\pmb{k}}{k}\tilde h(\pmb{k},t)exp(i\pmb{k.x})
$$

With that in hand, now we just need to add this components to original position of the grid. The lambda factor is user-controllable and tells how much the horizontal displacement is relevant, or how sharpen the waves are. 

$$
\pmb{x_f} = \pmb{x} + \lambda\pmb{D}(\pmb{x},t)
$$

## Ocean effects

### Foam 
To calculate the foam, we need to know were the waves fold into themselves. A good way to measure this is calculating the jacobian of the displacement map, the jacobian tell us whenever a transformations is unique or not, when J = 0, it means that when we apply the displacement map to the original point of the grid, two points assume the same value. So the jacobian is a useful parameter to determine if the waves are foldind into themselves, primarly we want to know where J < 0, and apply the foam to these points, but for a more realistic result, we analise other values like J < 0,3. The calculation of the jacobian can be seen above and was made using central differentiation, just like the normals. 

$$
J_{xx} = 1 + \lambda\frac{\partial{\pmb{D}_x(\pmb{x})}}{\partial{x}}
\\~\\
J_{zz} = 1 + \lambda\frac{\partial{\pmb{D}_z(\pmb{x})}}{\partial{z}}
\\~\\
 J_{xz} = J_{{zx}} = \lambda\frac{\partial{\pmb{D}_x(\pmb{x})}}{\partial{z}}
\\~\\
J(\pmb{x}) = J_{xx}J_{zz} - J_{xz}J_{zx}
$$

To paint the foam in the waves, we create a texture where each pixel correspondes to a value of the jacobian at that point, after that we multiply it by a foam texture and add to the ocean color.

### Illumination effects
The minimal effects of illumination that needs to be simulated on a ocean surface are reflection and reffraction. These two effects are quantitative evaluated through the fresnel equations for s-polarized light, shown above:

$$
R+T=1
$$

$$
R(\theta_i, \theta_t) = \left(\frac{n_1cos(\theta_i) - n_2cos(\theta_t)}{n_1cos(\theta_i) + n_2cos(\theta_t)}\right)²
$$

R can be seen as a probability function for the reflected ray, because its on the interval [0,1), so we can make use of this by using this number to interpolate between the color of the ocean and the sky, that is:

$$
C_f = lerp(SkyColor, OceanColor, R)
$$

To compute this more efficiently, we use the Schlik aproximation, wich is:

$$
R_o = (\frac{n_1-n_2}{n_1+n_2})^2
\\~\\
R(\theta) = R_o + (1-R_o)(1-cos(\theta))^5
$$

## References

